<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Who's That Pok&eacute;mon?</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

/* ===== BACK LINK ===== */
.back-link {
  position: absolute;
  top: 16px;
  left: 16px;
  text-decoration: none;
  color: #888;
  font-size: 0.85rem;
  padding: 6px 14px;
  border: 2px solid #1b2838;
  border-radius: 8px;
  background: #162447;
  transition: all 0.2s;
}

.back-link:hover {
  border-color: #e94560;
  color: #ccc;
  background: #1f3460;
}

header {
  text-align: center;
  margin-bottom: 16px;
}

h1 {
  font-size: 1.8rem;
  color: #e94560;
  margin-bottom: 4px;
}

.subtitle {
  color: #888;
  font-size: 0.95rem;
}

.gen-buttons {
  display: flex;
  gap: 8px;
  margin: 16px 0;
  flex-wrap: wrap;
  justify-content: center;
}

.gen-buttons button {
  padding: 10px 20px;
  border: 2px solid #1b2838;
  border-radius: 8px;
  background: #162447;
  color: #ccc;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.gen-buttons button:hover {
  background: #1f3460;
  border-color: #e94560;
  color: #fff;
}

.gen-buttons button.active {
  border-color: #e94560;
  background: #1a1a3e;
  color: #fff;
  box-shadow: 0 0 12px rgba(233, 69, 96, 0.25);
}

.sprite-container {
  width: 300px;
  height: 300px;
  background: #0d1b2a;
  border: 2px solid #1b2838;
  border-radius: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
  position: relative;
  overflow: hidden;
}

.sprite-container img {
  max-width: 260px;
  max-height: 260px;
  transition: filter 0.6s ease;
  image-rendering: auto;
}

.sprite-container img.silhouette {
  filter: brightness(0);
}

.sprite-container img.partial-reveal {
  filter: brightness(0.25) saturate(0);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #1b2838;
  border-top-color: #e94560;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.hint-buttons {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  justify-content: center;
}

.hint-buttons button {
  padding: 8px 16px;
  border: 2px solid #1b2838;
  border-radius: 8px;
  background: #162447;
  color: #ccc;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.hint-buttons button:hover:not(:disabled) {
  background: #1f3460;
  border-color: #e94560;
  color: #fff;
}

.hint-buttons button:disabled {
  opacity: 0.4;
  cursor: default;
}

.hint-text {
  color: #4ECDC4;
  font-size: 0.9rem;
  margin-bottom: 12px;
  min-height: 1.2em;
  text-align: center;
}

.feedback {
  font-size: 1rem;
  min-height: 1.4em;
  margin-bottom: 16px;
  text-align: center;
}

.feedback.correct {
  color: #4ECDC4;
  font-weight: 700;
}

.feedback.wrong {
  color: #e94560;
}

.choices {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  width: 100%;
  max-width: 420px;
  margin-bottom: 20px;
}

.choice-btn {
  padding: 14px 12px;
  border: 2px solid #1b2838;
  border-radius: 10px;
  background: #162447;
  color: #eee;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.choice-btn:hover:not(:disabled) {
  background: #1f3460;
  border-color: #e94560;
  color: #fff;
}

.choice-btn:disabled {
  cursor: default;
}

.choice-btn.correct-choice {
  border-color: #4ECDC4;
  background: rgba(78, 205, 196, 0.15);
  color: #4ECDC4;
}

.choice-btn.wrong-choice {
  border-color: #e94560;
  background: rgba(233, 69, 96, 0.15);
  color: #e94560;
}

.choice-btn.dimmed {
  opacity: 0.35;
}

.stats-bar {
  display: flex;
  gap: 24px;
  margin-bottom: 16px;
  font-size: 1rem;
  color: #ccc;
  flex-wrap: wrap;
  justify-content: center;
}

.stats-bar span {
  display: flex;
  align-items: center;
  gap: 6px;
}

.stats-bar .label {
  color: #888;
  font-size: 0.85rem;
}

.stats-bar .value {
  color: #fff;
  font-weight: 600;
}

.skip-btn {
  padding: 8px 20px;
  border: 2px solid #1b2838;
  border-radius: 8px;
  background: transparent;
  color: #888;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
}

.skip-btn:hover {
  border-color: #e94560;
  color: #ccc;
}

.pokemon-name {
  font-size: 1.5rem;
  font-weight: 700;
  color: #e94560;
  margin-bottom: 12px;
  text-align: center;
  min-height: 1.6em;
}

@media (max-width: 600px) {
  h1 { font-size: 1.4rem; }
  .sprite-container { width: 240px; height: 240px; }
  .sprite-container img { max-width: 200px; max-height: 200px; }
  .stats-bar { gap: 16px; font-size: 0.9rem; }
  .back-link {
    position: static;
    display: inline-block;
    margin-bottom: 8px;
  }
}
</style>
</head>
<body>

<a class="back-link" href="../">&#8592; Menu</a>

<header>
  <h1>Who's That Pok&eacute;mon?</h1>
  <p class="subtitle">Guess the Pok&eacute;mon from its silhouette!</p>
</header>

<div class="gen-buttons" id="gen-buttons">
  <button data-gen="1">Gen 1</button>
  <button data-gen="2">Gen 2</button>
  <button data-gen="3">Gen 3</button>
  <button data-gen="all" class="active">All</button>
</div>

<div class="sprite-container" id="sprite-container">
  <div class="spinner" id="spinner"></div>
  <img id="pokemon-sprite" style="display:none" alt="Pokemon silhouette">
</div>

<div class="pokemon-name" id="pokemon-name"></div>

<div class="hint-buttons" id="hint-buttons">
  <button data-hint="type" id="hint-type">Type (-20 pts)</button>
  <button data-hint="reveal" id="hint-reveal">Partial Reveal (-20 pts)</button>
</div>

<div class="hint-text" id="hint-text"></div>

<div class="feedback" id="feedback"></div>

<div class="choices" id="choices"></div>

<div class="stats-bar">
  <span><span class="label">Score:</span> <span class="value" id="score">0</span></span>
  <span><span class="label">Streak:</span> <span class="value" id="streak">0</span></span>
  <span><span class="label">Best Streak:</span> <span class="value" id="best-streak">0</span></span>
</div>

<button class="skip-btn" id="skip-btn" onclick="skipPokemon()">Skip / Give Up</button>

<script>
const GEN_RANGES = {
  '1': { offset: 0, limit: 151 },
  '2': { offset: 151, limit: 100 },
  '3': { offset: 251, limit: 135 },
  'all': { offset: 0, limit: 386 },
};

const SPRITE_BASE = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/';
const NUM_CHOICES = 4;

let pokemonList = {};  // gen -> [{name, id}]
let detailCache = {};  // id -> {types: [...]}
let evoCache = {};     // speciesId -> [name, name, ...] (all names in chain)
let currentGen = 'all';
let currentPokemon = null;  // {name, id}
let currentChoices = [];    // [{name, id}]
let hintsUsed = 0;
let usedHints = { type: false, reveal: false };
let score = 0;
let streak = 0;
let bestStreak = 0;
let revealed = false;

// Load persisted stats
function loadStats() {
  score = parseInt(localStorage.getItem('pokemon_score') || '0');
  streak = parseInt(localStorage.getItem('pokemon_streak') || '0');
  bestStreak = parseInt(localStorage.getItem('pokemon_best_streak') || '0');
  updateStatsDisplay();
}

function saveStats() {
  localStorage.setItem('pokemon_score', score);
  localStorage.setItem('pokemon_streak', streak);
  localStorage.setItem('pokemon_best_streak', bestStreak);
}

function updateStatsDisplay() {
  document.getElementById('score').textContent = score;
  document.getElementById('streak').textContent = streak;
  document.getElementById('best-streak').textContent = bestStreak;
}

// Fetch pokemon list for a generation
async function fetchPokemonList(gen) {
  if (pokemonList[gen]) return pokemonList[gen];

  const { offset, limit } = GEN_RANGES[gen];
  try {
    const resp = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit}`);
    const data = await resp.json();
    pokemonList[gen] = data.results.map((p, i) => ({
      name: p.name,
      id: offset + i + 1,
    }));
    return pokemonList[gen];
  } catch (err) {
    console.error('Failed to fetch pokemon list:', err);
    return [];
  }
}

// Fetch pokemon details (for type hint)
async function fetchPokemonDetail(id) {
  if (detailCache[id]) return detailCache[id];

  try {
    const resp = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    const data = await resp.json();
    detailCache[id] = {
      types: data.types.map(t => t.type.name),
    };
    return detailCache[id];
  } catch (err) {
    console.error('Failed to fetch pokemon detail:', err);
    return null;
  }
}

// Walk the evolution chain tree and collect all species names
function collectChainNames(chain) {
  const names = [chain.species.name];
  for (const evo of chain.evolves_to) {
    names.push(...collectChainNames(evo));
  }
  return names;
}

// Fetch evolution chain relatives for a pokemon
async function fetchEvolutionRelatives(pokemonName, pokemonId) {
  if (evoCache[pokemonId]) return evoCache[pokemonId];

  try {
    const speciesResp = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonId}`);
    const speciesData = await speciesResp.json();
    const chainUrl = speciesData.evolution_chain.url;

    const chainResp = await fetch(chainUrl);
    const chainData = await chainResp.json();

    const allNames = collectChainNames(chainData.chain);
    // Return relatives only (exclude self)
    const relatives = allNames.filter(n => n !== pokemonName);
    evoCache[pokemonId] = relatives;
    return relatives;
  } catch (err) {
    console.error('Failed to fetch evolution chain:', err);
    evoCache[pokemonId] = [];
    return [];
  }
}

// Format pokemon name for display
function formatName(name) {
  return name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-');
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Build choices: correct answer + evolution relatives + random fillers
async function buildChoices(pokemon, list) {
  const correctName = pokemon.name;
  const distractorNames = new Set();

  // Fetch evolution relatives (don't block rendering — sprite loads in parallel)
  const relatives = await fetchEvolutionRelatives(pokemon.name, pokemon.id);

  // Add evolution relatives as distractors first
  for (const name of relatives) {
    if (distractorNames.size >= NUM_CHOICES - 1) break;
    distractorNames.add(name);
  }

  // Fill remaining slots with random pokemon from the list
  const shuffled = shuffle([...list]);
  for (const p of shuffled) {
    if (distractorNames.size >= NUM_CHOICES - 1) break;
    if (p.name === correctName || distractorNames.has(p.name)) continue;
    distractorNames.add(p.name);
  }

  const choices = [correctName, ...distractorNames].map(name => ({ name }));
  return shuffle(choices);
}

// Start a new round
async function newRound() {
  revealed = false;
  hintsUsed = 0;
  usedHints = { type: false, reveal: false };

  document.getElementById('feedback').textContent = '';
  document.getElementById('feedback').className = 'feedback';
  document.getElementById('hint-text').textContent = '';
  document.getElementById('pokemon-name').textContent = '';
  document.getElementById('choices').innerHTML = '';
  document.getElementById('skip-btn').textContent = 'Skip / Give Up';

  // Reset hint buttons
  document.querySelectorAll('#hint-buttons button').forEach(b => b.disabled = false);

  // Show spinner, hide sprite
  document.getElementById('spinner').style.display = 'block';
  const img = document.getElementById('pokemon-sprite');
  img.style.display = 'none';

  const list = await fetchPokemonList(currentGen);
  if (list.length === 0) {
    document.getElementById('feedback').textContent = 'Failed to load Pokémon list. Check your connection.';
    document.getElementById('feedback').className = 'feedback wrong';
    return;
  }

  currentPokemon = list[Math.floor(Math.random() * list.length)];

  // Load sprite
  img.onload = () => {
    document.getElementById('spinner').style.display = 'none';
    img.style.display = 'block';
    img.className = 'silhouette';
  };
  img.onerror = () => {
    document.getElementById('spinner').style.display = 'none';
    document.getElementById('feedback').textContent = 'Failed to load sprite. Skipping...';
    document.getElementById('feedback').className = 'feedback wrong';
    setTimeout(newRound, 1500);
  };
  img.src = SPRITE_BASE + currentPokemon.id + '.png';

  // Build and render choices (fetches evo chain in parallel with sprite)
  currentChoices = await buildChoices(currentPokemon, list);
  renderChoices();
}

function renderChoices() {
  const container = document.getElementById('choices');
  container.innerHTML = '';

  currentChoices.forEach((choice, idx) => {
    const btn = document.createElement('button');
    btn.className = 'choice-btn';
    btn.textContent = formatName(choice.name);
    btn.addEventListener('click', () => handleChoice(idx, btn));
    container.appendChild(btn);
  });
}

function handleChoice(idx, btn) {
  if (revealed) return;

  const chosen = currentChoices[idx].name;
  const correct = currentPokemon.name;

  revealed = true;

  // Reveal the pokemon
  document.getElementById('pokemon-sprite').className = '';
  document.getElementById('pokemon-name').textContent = formatName(correct);

  // Disable all hint buttons
  document.querySelectorAll('#hint-buttons button').forEach(b => b.disabled = true);

  // Highlight all buttons
  const allBtns = document.querySelectorAll('.choice-btn');
  allBtns.forEach((b, i) => {
    b.disabled = true;
    if (currentChoices[i].name === correct) {
      b.classList.add('correct-choice');
    } else if (i === idx) {
      b.classList.add('wrong-choice');
    } else {
      b.classList.add('dimmed');
    }
  });

  if (chosen === correct) {
    const pts = Math.max(100 - hintsUsed * 20, 20);
    score += pts;
    streak++;
    if (streak > bestStreak) bestStreak = streak;
    saveStats();
    updateStatsDisplay();

    document.getElementById('feedback').textContent = 'Correct! +' + pts + ' points';
    document.getElementById('feedback').className = 'feedback correct';
  } else {
    streak = 0;
    saveStats();
    updateStatsDisplay();

    document.getElementById('feedback').textContent = 'Wrong! It was ' + formatName(correct) + '!';
    document.getElementById('feedback').className = 'feedback wrong';
  }

  document.getElementById('skip-btn').textContent = 'Next Pokémon';
}

function skipPokemon() {
  if (revealed) {
    newRound();
    return;
  }

  // Give up — reveal answer
  revealed = true;
  streak = 0;
  saveStats();
  updateStatsDisplay();

  document.getElementById('pokemon-sprite').className = '';
  document.getElementById('pokemon-name').textContent = formatName(currentPokemon.name);
  document.getElementById('feedback').textContent = 'It was ' + formatName(currentPokemon.name) + '!';
  document.getElementById('feedback').className = 'feedback wrong';
  document.getElementById('skip-btn').textContent = 'Next Pokémon';

  document.querySelectorAll('#hint-buttons button').forEach(b => b.disabled = true);

  // Highlight correct choice
  const allBtns = document.querySelectorAll('.choice-btn');
  allBtns.forEach((b, i) => {
    b.disabled = true;
    if (currentChoices[i].name === currentPokemon.name) {
      b.classList.add('correct-choice');
    } else {
      b.classList.add('dimmed');
    }
  });
}

// Hint handlers
document.getElementById('hint-buttons').addEventListener('click', async (e) => {
  const btn = e.target.closest('button');
  if (!btn || btn.disabled || !currentPokemon || revealed) return;

  const hint = btn.dataset.hint;
  if (usedHints[hint]) return;

  usedHints[hint] = true;
  hintsUsed++;
  btn.disabled = true;

  if (hint === 'type') {
    const detail = await fetchPokemonDetail(currentPokemon.id);
    if (detail) {
      document.getElementById('hint-text').textContent =
        'Type: ' + detail.types.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(' / ');
    }
  } else if (hint === 'reveal') {
    document.getElementById('pokemon-sprite').className = 'partial-reveal';
    document.getElementById('hint-text').textContent = 'Silhouette partially revealed!';
  }
});

// Gen buttons
document.getElementById('gen-buttons').addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;
  document.querySelectorAll('.gen-buttons button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  currentGen = btn.dataset.gen;
  newRound();
});

// Init
loadStats();
newRound();
</script>
</body>
</html>
